<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>CALayer那些东西 | 王小禅</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">CALayer那些东西</h1><a id="logo" href="/.">王小禅</a><p class="description">iOS攻城狮，也在学习前端，正在努力成为更好的自己</p></div><div id="nav-menu"><a href="/." class="current"><i class="icon-home"> 首页</i></a><a href="/archives/"><i class="icon-archive"> 归档</i></a><a href="/about/"><i class="icon-about"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">CALayer那些东西</h1><div class="post-meta">2016-01-22 | </div><div class="post-content"><p><em>update: 2016-01-22 15:45:32</em></p>
<p>资料来自于<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques</a></p>
<h2 id="CALayer_u7684_u6982_u5FF5"><a href="#CALayer_u7684_u6982_u5FF5" class="headerlink" title="CALayer的概念"></a>CALayer的概念</h2><p>CALayer类和UIView类似，被层级关系树管理的矩形块，也可以包含一些内容（像图片，文本或者背景色），管理子图层的位置。它们有一些方法和属性用来做动画和变换。和UIView最大的不同是CALayer不处理用户的交互。</p>
<p>每一个UIview都有一个CALayer实例的图层属性，也就是所谓的backing layer，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作。</p>
<h2 id="CALayer_u7684_u5C5E_u6027"><a href="#CALayer_u7684_u5C5E_u6027" class="headerlink" title="CALayer的属性"></a>CALayer的属性</h2><ul>
<li>bounds</li>
<li>position</li>
<li>zPosition</li>
<li>anchorPoint</li>
<li>anchorPoint</li>
<li>transform</li>
<li>affineTransform</li>
<li>frame</li>
<li>hidden</li>
<li>geometryFlipped</li>
<li>contentsAreFlipped</li>
<li>superLayer</li>
<li>sublayers</li>
<li>sublayerTransform</li>
<li>mask</li>
<li>masksToBounds</li>
<li>contents</li>
<li>contentsRect</li>
<li>contentsGravity</li>
<li>contentsScale</li>
<li>contentsCenter</li>
<li>minificationFilter</li>
<li>magnificationFilter</li>
<li>minificationFilterBias</li>
<li>opaque</li>
<li>needsDisplayOnBoundsChange</li>
<li>drawsAsynchronously</li>
<li>edgeAntialiasingMask</li>
<li>allowsEdgeAntialiasing</li>
<li>backgroundColor</li>
<li>cornerRadius</li>
<li>borderWidth</li>
<li>borderColor</li>
<li>opacity</li>
<li>allowsGroupOpacity</li>
<li>compositingFilter</li>
<li>filters</li>
<li>backgroundFilters</li>
<li>shouldRasterize</li>
<li>rasterizationScale</li>
<li>shadowColor</li>
<li>shadowOpacity</li>
<li>shadowOffset</li>
<li>shadowRadius</li>
<li>shadowPath</li>
<li>actions</li>
<li>name</li>
<li>delegate</li>
<li>style</li>
</ul>
<h2 id="u7CFB_u7EDF_u5E93_u63D0_u4F9BLayer"><a href="#u7CFB_u7EDF_u5E93_u63D0_u4F9BLayer" class="headerlink" title="系统库提供Layer"></a>系统库提供Layer</h2><h3 id="1-CAShapeLayer"><a href="#1-CAShapeLayer" class="headerlink" title="1.CAShapeLayer"></a>1.CAShapeLayer</h3><p>CAShapeLayer是一个通过矢量图形而不是bitmap来绘制的图层子类。<br>    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">UIBezierPath *path = [UIBezierPath bezierPath];</span><br><span class="line">[path moveToPoint:CGPointMake(<span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">[path addLineToPoint:CGPointMake(<span class="number">200</span>, <span class="number">200</span>)];</span><br><span class="line">[path addLineToPoint:CGPointMake(<span class="number">100</span>, <span class="number">300</span>)];</span><br><span class="line">[path addLineToPoint:CGPointMake(<span class="number">300</span>, <span class="number">400</span>)];</span><br><span class="line">[path closePath];</span><br><span class="line">CAShapeLayer *shapeLayer = [CAShapeLayer layer];</span><br><span class="line">shapeLayer.strokeColor = [UIColor greenColor].CGColor;</span><br><span class="line">shapeLayer.lineWidth = <span class="number">2.0</span>;</span><br><span class="line">shapeLayer.lineCap = kCALineCapRound;</span><br><span class="line">shapeLayer.lineJoin = kCALineJoinRound;</span><br><span class="line">shapeLayer.path = path.CGPath;</span><br><span class="line">[self.containerView.layer addSublayer:shapeLayer];</span><br><span class="line">[shapeLayer removeFromSuperlayer];</span><br><span class="line">CGSize rad = CGSizeMake(<span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">UIRectCorner corner = UIRectCornerBottomLeft | UIRectCornerBottomRight;</span><br><span class="line">path = [UIBezierPath bezierPathWithRoundedRect:self.containerView.frame byRoundingCorners:corner cornerRadii:rad];</span><br><span class="line">[self.containerView.layer addSublayer:shapeLayer];</span><br></pre></td></tr></table></figure></p>
<h3 id="2-CATextLayer"><a href="#2-CATextLayer" class="headerlink" title="2.CATextLayer"></a>2.CATextLayer</h3><p>在图层中显示文字的Layer。CATextLayer以图层的形式包含了UILabel几乎所有的绘制特性，并且额外提供了一些新的特性。<br>可以使用NSAttributedString实现富文本效果。<br>    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">CATextLayer *textLayer = [CATextLayer layer];</span><br><span class="line">textLayer.frame = CGRectMake(<span class="number">0</span>, <span class="number">100</span>, <span class="number">320</span>, <span class="number">450</span>);</span><br><span class="line">textLayer.foregroundColor = [UIColor greenColor].CGColor;</span><br><span class="line">textLayer.alignmentMode = kCAAlignmentCenter;</span><br><span class="line">textLayer.wrapped = YES;</span><br><span class="line">UIFont *font = [UIFont systemFontOfSize:<span class="number">30</span>];</span><br><span class="line">CFStringRef stringRef = (__bridge CFStringRef) font.fontName;</span><br><span class="line">CGFontRef fontRef = CGFontCreateWithFontName(stringRef);</span><br><span class="line">textLayer.font = fontRef;</span><br><span class="line">textLayer.fontSize = font.pointSize;</span><br><span class="line">CGFontRelease(fontRef);</span><br><span class="line">CFRelease(fontRef);</span><br><span class="line">textLayer.<span class="built_in">string</span> = @<span class="string">"this is test message!"</span>;</span><br><span class="line">textLayer.contentsScale = [UIScreen mainScreen].scale;</span><br><span class="line">[self.view.layer addSublayer:textLayer];</span><br><span class="line"><span class="comment">//富文本效果</span></span><br><span class="line">NSString *<span class="built_in">string</span> = @<span class="string">"Lorem ipsum dolor sit amet, consecteture adipiscing elit. Quisque massa arcu, eleifend vel varius in, facilisis pulvinar leo. Nunc quis nunc at mauris pharetra condimentum ut ac neque. Nunc elementum, libero ut porttitor dictum, diam odio congue lacus, vel fringilla sapien diam at purus. Etiam suscipit pretium nunc sit amet lobortis"</span>;</span><br><span class="line">NSMutableAttributedString *attrString = [[NSMutableAttributedString alloc] initWithString:<span class="built_in">string</span>];</span><br><span class="line">UIFont *font = [UIFont systemFontOfSize:<span class="number">15.0</span>];</span><br><span class="line">CFStringRef stringRef = (__bridge CFStringRef)font.fontName;</span><br><span class="line">CTFontRef fontRef = CTFontCreateWithName(stringRef, font.pointSize, <span class="literal">NULL</span>);</span><br><span class="line">NSDictionary *attrDic = @&#123;</span><br><span class="line">                          (__bridge id)kCTForegroundColorAttributeName : (__bridge id)[UIColor lightTextColor].CGColor,</span><br><span class="line">                          (__bridge id)kCTFontAttributeName : (__bridge id)fontRef</span><br><span class="line">                          &#125;;</span><br><span class="line">[attrString setAttributes:attrDic range:NSMakeRange(<span class="number">0</span>, <span class="built_in">string</span>.length)];</span><br><span class="line">attrDic = @&#123;</span><br><span class="line">            (__bridge id)kCTForegroundColorAttributeName : (__bridge id)[UIColor redColor].CGColor,</span><br><span class="line">            (__bridge id)kCTUnderlineStyleAttributeName : @(kCTUnderlineStyleSingle),</span><br><span class="line">            (__bridge id)kCTFontAttributeName : (__bridge id)fontRef</span><br><span class="line">            &#125;;</span><br><span class="line">[attrString addAttributes:attrDic range:NSMakeRange(<span class="number">6</span>, <span class="number">5</span>)];</span><br><span class="line">CFRelease(fontRef);</span><br><span class="line">textLayer.<span class="built_in">string</span> = attrString;</span><br><span class="line">textLayer.contentsScale = [UIScreen mainScreen].scale;</span><br><span class="line">[self.view.layer addSublayer:textLayer];</span><br></pre></td></tr></table></figure></p>
<h3 id="3-CAGradientLayer"><a href="#3-CAGradientLayer" class="headerlink" title="3.CAGradientLayer"></a>3.CAGradientLayer</h3><p>CAGradientLayer是用来生成两种或更多颜色平滑渐变的。<br>    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CAGradientLayer *gradiengLayer = [CAGradientLayer layer];</span><br><span class="line">gradiengLayer.colors = @[(__bridge id)[UIColor whiteColor].CGColor, (__bridge id)[UIColor redColor].CGColor, (__bridge id)[UIColor greenColor].CGColor, (__bridge id)[UIColor grayColor].CGColor];</span><br><span class="line">gradiengLayer.frame = CGRectMake(<span class="number">20</span>, <span class="number">20</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">gradiengLayer.startPoint = CGPointMake(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">gradiengLayer.endPoint = CGPointMake(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">gradiengLayer.locations = @[@<span class="number">0.10</span>, @<span class="number">0.35</span>, @<span class="number">0.64</span>];</span><br><span class="line">[self.view.layer addSublayer:gradiengLayer];</span><br></pre></td></tr></table></figure></p>
<h3 id="4-CAReplicatorLayer"><a href="#4-CAReplicatorLayer" class="headerlink" title="4.CAReplicatorLayer"></a>4.CAReplicatorLayer</h3><p>CAReplicatorLayer的目的是为了高效生成许多相似的图层。它会绘制一个或多个图层的子图层，并在每个复制体上应用不同的变换。<br>    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CAReplicatorLayer *replicatorLayer = [CAReplicatorLayer layer];</span><br><span class="line">replicatorLayer.instanceCount = <span class="number">2</span>;</span><br><span class="line">replicatorLayer.frame = CGRectMake(<span class="number">20</span>, <span class="number">20</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">CATransform3D transform = CATransform3DIdentity;</span><br><span class="line">transform = CATransform3DTranslate(transform, <span class="number">0</span>, replicatorLayer.bounds.size.height + <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">replicatorLayer.instanceTransform = transform;</span><br><span class="line">replicatorLayer.instanceAlphaOffset = <span class="number">0.6</span>;</span><br><span class="line">[self.view.layer addSublayer:replicatorLayer];</span><br></pre></td></tr></table></figure></p>
<h3 id="5-CATiledLayer"><a href="#5-CATiledLayer" class="headerlink" title="5.CATiledLayer"></a>5.CATiledLayer</h3><p>有些时候你可能需要绘制一个很大的图片，常见的例子就是一个高像素的照片或者是地球表面的详细地图。iOS应用通畅运行在内存受限的设备上，所以读取整个图片到内存中是不明智的。载入大图可能会相当地慢，那些对你看上去比较方便的做法（在主线程调用UIImage的-imageNamed:方法或者-imageWithContentsOfFile:方法）将会阻塞你的用户界面，至少会引起动画卡顿现象。</p>
<p>能高效绘制在iOS上的图片也有一个大小限制。所有显示在屏幕上的图片最终都会被转化为OpenGL纹理，同时OpenGL有一个最大的纹理尺寸（通常是2048*2048，或4096*4096，这个取决于设备型号）。如果你想在单个纹理中显示一个比这大的图，即便图片已经存在于内存中了，你仍然会遇到很大的性能问题，因为Core Animation强制用CPU处理图片而不是更快的GPU（见第12章『速度的曲调』，和第13章『高效绘图』，它更加详细地解释了软件绘制和硬件绘制）。</p>
<p>CATiledLayer为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入。让我们用实验来证明一下。<br>    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CATiledLayer *tileLayer = [CATiledLayer layer];</span><br><span class="line">tileLayer.frame = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2048</span>, <span class="number">2048</span>);</span><br><span class="line">tileLayer.delegate = self;</span><br><span class="line">[self.view.layer addSublayer:tileLayer];</span><br><span class="line">[tileLayer setNeedsDisplay];</span><br></pre></td></tr></table></figure></p>
<h3 id="6-CAScrollLayer"><a href="#6-CAScrollLayer" class="headerlink" title="6.CAScrollLayer"></a>6.CAScrollLayer</h3><p>对于一个未转换的图层，它的bounds和它的frame是一样的，frame属性是由bounds属性自动计算而出的，所以更改任意一个值都会更新其他值。在图层中等价于UIScrollView和UITableView。</p>
<h3 id="7-CAEmitterLayer"><a href="#7-CAEmitterLayer" class="headerlink" title="7.CAEmitterLayer"></a>7.CAEmitterLayer</h3><p>CAEmitterLayer是一个高性能的粒子引擎，被用来创建实时例子动画如：烟雾，火，雨等等这些效果。<br>    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    CAEmitterLayer *emlayer = [CAEmitterLayer layer];</span><br><span class="line">    emlayer.frame = CGRectMake(<span class="number">120</span>, <span class="number">120</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">    [self.view.layer addSublayer:emlayer];</span><br><span class="line">    emlayer.renderMode = kCAEmitterLayerAdditive;</span><br><span class="line">    emlayer.emitterPosition = CGPointMake(emlayer.frame.size.width / <span class="number">2.0</span>, emlayer.frame.size.height / <span class="number">2.0</span>);</span><br><span class="line">    CAEmitterCell *cell = [[CAEmitterCell alloc] init];</span><br><span class="line">    cell.contents = (__bridge id)[UIImage imageNamed:@<span class="string">"bear"</span>].CGImage;</span><br><span class="line"><span class="comment">//    cell.color = [UIColor colorWithWhite:0.8 alpha:0.33].CGColor;</span></span><br><span class="line">    cell.birthRate = <span class="number">200</span>;</span><br><span class="line">    cell.lifetime = <span class="number">3.0</span>;</span><br><span class="line">    cell.alphaSpeed = -<span class="number">0.3</span>;</span><br><span class="line">    cell.velocity = <span class="number">50.0</span>;</span><br><span class="line">    cell.velocityRange = <span class="number">50.0</span>;</span><br><span class="line">    cell.emissionRange = M_PI * <span class="number">2.0</span>;</span><br><span class="line">    emlayer.emitterCells = @[cell];</span><br></pre></td></tr></table></figure></p>
<h3 id="8-CAEAGLLayer"><a href="#8-CAEAGLLayer" class="headerlink" title="8.CAEAGLLayer"></a>8.CAEAGLLayer</h3><p>基于OpenGL实现的Layer，可实现高性能图像绘制，用起来复杂。</p>
<h3 id="9-AVPlayerLayer"><a href="#9-AVPlayerLayer" class="headerlink" title="9.AVPlayerLayer"></a>9.AVPlayerLayer</h3><p>AVPlayerLayer不是Core Animation框架的一部分（AV前缀看上去像），AVPlayerLayer是有别的框架（AVFoundation）提供的，它和Core Animation紧密地结合在一起，提供了一个CALayer子类来显示自定义的内容类型。</p>
<p>AVPlayerLayer是用来在iOS上播放视频的。他是高级接口例如MPMoivePlayer的底层实现，提供了显示视频的底层控制。AVPlayerLayer的使用相当简单：你可以用+playerLayerWithPlayer:方法创建一个已经绑定了视频播放器的图层，或者你可以先创建一个图层，然后用player属性绑定一个AVPlayer实例。<br>    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSString *urlString = [[NSBundle mainBundle] pathForResource:@<span class="string">"loadfile"</span> ofType:@<span class="string">"mp4"</span>];</span><br><span class="line">NSURL *videoUrl = [NSURL fileURLWithPath:urlString];</span><br><span class="line">AVPlayer *player = [AVPlayer playerWithURL:videoUrl];</span><br><span class="line">AVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:player];</span><br><span class="line">playerLayer.frame = CGRectMake(<span class="number">20</span>, <span class="number">20</span>, <span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">playerLayer.backgroundColor = [UIColor redColor].CGColor;</span><br><span class="line">playerLayer.videoGravity = AVLayerVideoGravityResizeAspectFill;</span><br><span class="line">CATransform3D transform = CATransform3DIdentity;</span><br><span class="line">transform.m34 = -<span class="number">1.0</span> / <span class="number">500.0</span>;</span><br><span class="line">transform = CATransform3DRotate(transform, M_PI_4, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">playerLayer.transform = transform;</span><br><span class="line">playerLayer.cornerRadius = <span class="number">3.0</span>;</span><br><span class="line">[self.view.layer addSublayer:playerLayer];</span><br><span class="line">[player play];</span><br></pre></td></tr></table></figure></p>
</div><div class="tags"><a href="/tags/iOS/">iOS</a></div><div class="post-nav"><a href="/2016/01/17/Runloop/" class="next">Runloop<i class="icon-next"></i></a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/Obj-C/" style="font-size: 15px;">Obj-C</a> <a href="/tags/iOS常见错误/" style="font-size: 15px;">iOS常见错误</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/ARC/" style="font-size: 15px;">ARC</a> <a href="/tags/计划/" style="font-size: 15px;">计划</a> <a href="/tags/总结/" style="font-size: 15px;">总结</a></div></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">王小禅.</a> Powered by zenzzy</div><a id="rocket" href="#top" class="show"></a><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script>
<script src="/js/jquery.fancybox.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"></div></body></html>